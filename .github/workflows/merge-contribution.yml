name: Merge Approved Contribution

on:
  issues:
    types: [labeled]

jobs:
  create-pr:
    if: "github.event.label.name == 'status: approved'"
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Extract YAML and Create File
        id: extract
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          python << 'PYTHON_SCRIPT'
          import yaml
          import re
          import os
          import json
          import sys
          from datetime import date

          # Read issue body from the GitHub event file (secure method)
          event_path = os.environ.get('GITHUB_EVENT_PATH', '')
          if not event_path or not os.path.exists(event_path):
              print("::error::Could not read GitHub event file")
              sys.exit(1)

          try:
              with open(event_path, 'r', encoding='utf-8') as f:
                  event_data = json.load(f)
          except (json.JSONDecodeError, IOError) as e:
              print(f"::error::Failed to parse event file: {e}")
              sys.exit(1)

          issue_body = event_data.get('issue', {}).get('body', '')

          if not issue_body:
              print("::error::Issue body is empty")
              sys.exit(1)

          # Limit issue body size to prevent DoS (max 100KB)
          MAX_BODY_SIZE = 100 * 1024
          if len(issue_body) > MAX_BODY_SIZE:
              print(f"::error::Issue body exceeds maximum size of {MAX_BODY_SIZE} bytes")
              sys.exit(1)

          # Extract YAML from code block
          yaml_match = re.search(r'```ya?ml\s*(.*?)\s*```', issue_body, re.DOTALL)
          if not yaml_match:
              print("::error::No YAML code block found in issue body")
              sys.exit(1)

          yaml_content = yaml_match.group(1).strip()

          # Limit YAML content size
          MAX_YAML_SIZE = 50 * 1024
          if len(yaml_content) > MAX_YAML_SIZE:
              print(f"::error::YAML content exceeds maximum size of {MAX_YAML_SIZE} bytes")
              sys.exit(1)

          try:
              data = yaml.safe_load(yaml_content)
          except yaml.YAMLError as e:
              print(f"::error::Invalid YAML syntax: {e}")
              sys.exit(1)

          if not isinstance(data, dict):
              print("::error::YAML must be a dictionary/mapping")
              sys.exit(1)

          # Generate filename (sanitize to prevent path traversal)
          name = data.get('name', 'unnamed')
          if not isinstance(name, str):
              name = 'unnamed'
          filename = re.sub(r'[^a-z0-9]+', '_', name.lower()).strip('_')
          # Additional sanitization
          filename = filename[:100]  # Limit length
          if not filename:
              filename = 'unnamed_query'

          # Validate filename doesn't contain path traversal attempts
          if '..' in filename or '/' in filename or '\\' in filename:
              print("::error::Invalid characters in filename")
              sys.exit(1)

          # Determine subdirectory based on content_type
          content_type = data.get('content_type', 'hunting')
          if not isinstance(content_type, str):
              content_type = 'hunting'

          # Whitelist allowed content types to prevent directory traversal
          subdir_map = {
              'hunting': 'hunting',
              'bioc': 'bioc',
              'correlation': 'correlation',
              'hygiene': 'hygiene',
              'widget': 'widgets'
          }
          subdir = subdir_map.get(content_type, '')

          # Create directory if needed
          if subdir:
              os.makedirs(f"queries/{subdir}", exist_ok=True)
              filepath = f"queries/{subdir}/{filename}.yaml"
          else:
              filepath = f"queries/{filename}.yaml"

          # Add created date if not present
          if 'created' not in data:
              data['created'] = date.today().isoformat()

          # Write file with proper formatting
          with open(filepath, 'w', encoding='utf-8') as f:
              yaml.dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

          # Sanitize outputs for GitHub Actions
          def sanitize_output(value):
              """Escape special characters for GitHub Actions output"""
              if not isinstance(value, str):
                  value = str(value)
              # Escape newlines and other special characters
              return value.replace('%', '%25').replace('\n', '%0A').replace('\r', '%0D')

          query_name = sanitize_output(data.get('name', 'Unknown'))
          author = sanitize_output(data.get('author', 'Unknown'))

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"filepath={filepath}\n")
              f.write(f"filename={filename}\n")
              f.write(f"query_name={query_name}\n")
              f.write(f"author={author}\n")
              f.write(f"content_type={content_type}\n")

          print(f"Created: {filepath}")
          PYTHON_SCRIPT

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        id: cpr
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Add: ${{ steps.extract.outputs.query_name }}"
          title: "Add: ${{ steps.extract.outputs.query_name }}"
          body: |
            ## New Query Contribution

            **Query Name:** ${{ steps.extract.outputs.query_name }}
            **Author:** ${{ steps.extract.outputs.author }}
            **Type:** ${{ steps.extract.outputs.content_type }}
            **File:** `${{ steps.extract.outputs.filepath }}`

            ---

            Auto-generated PR from issue #${{ github.event.issue.number }}

            Closes #${{ github.event.issue.number }}

            ---

            ### Checklist for Maintainers
            - [ ] Query has been reviewed
            - [ ] MITRE mappings are correct
            - [ ] No sensitive data present
            - [ ] Query follows naming conventions
          branch: contribution-${{ github.event.issue.number }}
          labels: contribution

      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ðŸš€ **Pull Request Created!**

            Your contribution has been approved and a PR has been created:

            **PR:** #${{ steps.cpr.outputs.pull-request-number }}
            **File:** \`${{ steps.extract.outputs.filepath }}\`

            The PR will be merged by a maintainer shortly. Thank you for your contribution! ðŸŽ‰`
            });